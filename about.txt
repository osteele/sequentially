h1. Sequentially: Temporal and Frequency Adverbs for JavaScript

<dfn><a href="/sources/javascript/sequentially">Sequentially</a></dfn> is a JavaScript library for asychronous programming.  It makes it easy to define functions that are called later, or periodically, or only a certain number of times, or only a certain number of times per unit time.

<code>
<pre>
// Run a function five times in a row
fn.only(5).repeatedly()
// Run a function five times, at one second intervals
fn.only(5).periodically()
// Make a new function that calls fn at most five times, no matter
// how often g is called
g = fn.only(5)
// Make a new functions that calls fn at most once per minute,
// no matter how frequently g is called
g = fn.infrequently(60*1000)
// Apply a function to each of the elements of an array, at intervals
// of once per second
['here', 'are', 'some', 'elements'].sequentially(
  function(word) {console.info(word, '->', word.length)})
  .periodically()
</pre>
</code>

I made a <a href="/sources/javascript/sequentially">page of examples</a> where you can run these examples in your browser.  It lets you mouse over the source code to see which outputs came from each block, and click on the outputs to see which source code each one came from.  This makes it easier to see what's going on.

h3. Why?

I'd like to be able to use the Erlang paradigm for client/server code --- to write clients that use cheap and unreliable servers for everything except user account management, with failover and retries.

Recently I wrote an application that did this:

Ask the content server for an image.  If it's not there, ask the application server to queue a request to the image server to create it.  Then check back with the content server again.  If the asset doesn't show up after a while, the application server may have been down or overloaded, so ask it again.  But I don't want my clients to mount a DDoS attack on an ailing server, so throttle the frequency of the requests, and give up after a while.

My first pass at this was a tangled mess of domain logic, network requests, and control code.  It was way harder than it ought to have been, especially for such a general design a pattern.

The basic ideas here are really simple: repetition (keep asking, but not too many times) and frequency (...and not too frequently).  You can think of <dfn>Sequentially</dfn> as a tiny little domain-specific extension to JavaScript that adds the words for these concepts.

h3. Some Analogies

I use this in a style I call "adverbial programming".  Someday I'll post an entry about the analogy between computer languages and natural languages; for now, simply note that methods such as "eventually" and "repeatedly" modify a function (a verb) to produce a new functions with a related meaning --- this is the same as (one of the three sense of) an adverb.

This is in contrast to procedural programming, which assembles statements into paragraphs; object-oriented programming, which is all about noun phrases; and functional programming, which is largely about verbs.  (Closures, which bridge the gap between the functional and OO style, are gerunds.)

Here are some other analogies that I found helpful in thinking about how to think about this and where to go next.  You could think of Sequentially as a kind of memoization, where instead of caching the result it modifies <em>when</em> and<em>whether</em> a function is called.  Alternatively (and very loosely), it's the CPS conversion of the categorical dual of <a href="http://en.wikipedia.org/wiki/Generator_%28computer_science%29">generators</a> (modifying sinks instead of sources). Or, if you take the call graph of a program, turn that into a dataflow diagram, and implement that in OO, then Sequentially consists of decorators for the pipes.  Or maybe it's the Chu space dual of <a href="/sources/javascript/functional">Functional JavaScript</a>.  Oh, never mind, it's just a few combinators for frequency, iteration, and time.</p>


Sequentially uses closures to embed (some of) the <a
        href="http://en.wikipedia.org/wiki/Pi-calculus">&pi;-calculus</a>
        in JavaScript.


[1] More accurately, functional programming is about saturating the argument positions of both nouns and verbs.  Its closest analogy is to theories of language, such as Montague Grammar and Categorial grammar, rather than to  doesn't have a clear linguistic analogy, which may be why it's harder to understand.

        <em>Stylistically</em>, Sequentially can be used in
        <dfn>adverbial programming</dfn>, a paradigm that complements
        procedural (verb-base), object-oriented (noun-based), and
        functional (gerundive) programming.  <em>Theoretically</em>,
        Sequentially uses closures to embed (some of) the <a
        href="http://en.wikipedia.org/wiki/Pi-calculus">&pi;-calculus</a>
        in JavaScript.  Alternatively, it's the CPS conversion of the
        categorical dual of <a
        href="http://en.wikipedia.org/wiki/Generator_%28computer_science%29">generators</a>.
        Or maybe it's the Chu space dual of <a
        href="../functional">Functional JavaScript</a>.  Oh, never
        mind, it's just a few combinators for frequency,
        iteration, and time.</p>

        <p><em>Functionally</em>, Sequentially combines data flow
        programming with simple process scheduling.




clauses with temporal links
contingent requests



* Topics
- mvar vs. queue

I never really got used to threads.  The experience of programming with multiple threads was frustrating for me.  The parts of the program that worked with synchronization were never integrated with the parts that weren't, and I continually had to move the firewall between the synchronized and thread-blind portion of the program.  (Sort of like the const/mutable firewall in C, or the Monad/expression firewall in Haskell.)

I find it much more intuitive to think in terms of these little workers and waiters and watchers and listeners that you spin off.  It's the daemon idea from AI.


In categorial grammar, an adverb is a function that modifies a verb into another adverb[1].  Functions are the verbs of programming languages (and objects are the nouns); an adverb is a function that modifies a function by returning an output that is based on the input.  (In math, these higher-order functions are called functionals.)

Object-oriented programming is all about nouns.  You can see this in some design patterns; the decorator pattern implements adjectives (elements that wrap a noun to produce a new noun).  The collection pattern implements conjunctions: distinct objects are coordinated into a single one.

Nouns are object; functions are verbs; statements are sentences.  A statement is evaluated for its effect on the mutable state of the program and the world; likewise, a natural-language sentence has an effect on the discourse model.  Some statements (IO statements, and other statements that manipulate external resources) have an effect on the world too; in natural language, these kinds of sentences, which reach outside of the discourse model, are performatives.

Closures are gerunds.  English has distinct syntactic positions for

Function-level programming isn't really at the level of language use.  Using a functional programming style is similar to theorizing about natural language: curried (partially saturated) functions are the bread and butter of Montague and categorial grammars.

fn1. In the interest of brevity, I'm going to distinguish between verbs and verb phrases, and between nouns and noun phrases.  Pretty much everything that I call a noun here is really a noun phrase, or at least an N bar.  Likewise, I'm not going to specify verbal advebs here. English has three different things called adverbs; I'm only talking about one of them here.
